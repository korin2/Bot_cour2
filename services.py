import requests
import xml.etree.ElementTree as ET
import json
from bs4 import BeautifulSoup
from datetime import datetime, timedelta
import logging
import re
from config import CBR_API_BASE, COINGECKO_API_BASE, DEEPSEEK_API_BASE, DEEPSEEK_API_KEY, logger
from telegram.ext import ContextTypes

# =============================================================================
# –§–£–ù–ö–¶–ò–ò –î–õ–Ø –†–ê–ë–û–¢–´ –° –ö–£–†–°–ê–ú–ò –í–ê–õ–Æ–¢ –¶–ë –†–§
# =============================================================================

def get_currency_rates_for_date(date_req):
    """–ü–æ–ª—É—á–∞–µ—Ç –∫—É—Ä—Å—ã –≤–∞–ª—é—Ç –Ω–∞ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω—É—é –¥–∞—Ç—É"""
    try:
        url = f"{CBR_API_BASE}scripts/XML_daily.asp"
        params = {'date_req': date_req}
        
        response = requests.get(url, params=params, timeout=10)
        if response.status_code != 200:
            return None, None
        
        root = ET.fromstring(response.content)
        cbr_date = root.get('Date', '')
        
        rates = {}
        currency_codes = {
            'R01235': 'USD',  'R01239': 'EUR',  'R01035': 'GBP',  'R01820': 'JPY',
            'R01375': 'CNY',  'R01775': 'CHF',  'R01350': 'CAD',  'R01010': 'AUD',
            'R01700': 'TRY',  'R01335': 'KZT',
        }
        
        for valute in root.findall('Valute'):
            valute_id = valute.get('ID')
            if valute_id in currency_codes:
                currency_code = currency_codes[valute_id]
                name = valute.find('Name').text
                value = float(valute.find('Value').text.replace(',', '.'))
                nominal = int(valute.find('Nominal').text)
                
                if nominal > 1:
                    value = value / nominal
                
                rates[currency_code] = {
                    'value': value,
                    'name': name,
                    'nominal': nominal
                }
        
        return rates, cbr_date
        
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –∫—É—Ä—Å–æ–≤ –Ω–∞ –¥–∞—Ç—É {date_req}: {e}")
        return None, None

def get_currency_rates_with_tomorrow():
    """–ü–æ–ª—É—á–∞–µ—Ç –∫—É—Ä—Å—ã –≤–∞–ª—é—Ç –Ω–∞ —Å–µ–≥–æ–¥–Ω—è –∏ –∑–∞–≤—Ç—Ä–∞ (–µ—Å–ª–∏ –¥–æ—Å—Ç—É–ø–Ω–æ)"""
    try:
        today = datetime.now()
        tomorrow = today + timedelta(days=1)
        
        # –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º –¥–∞—Ç—ã –¥–ª—è –∑–∞–ø—Ä–æ—Å–∞
        date_today = today.strftime('%d/%m/%Y')
        date_tomorrow = tomorrow.strftime('%d/%m/%Y')
        
        # –ü–æ–ª—É—á–∞–µ–º –∫—É—Ä—Å—ã –Ω–∞ —Å–µ–≥–æ–¥–Ω—è
        rates_today, date_today_str = get_currency_rates_for_date(date_today)
        if not rates_today:
            return {}, '–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –¥–∞—Ç–∞', None, None
        
        # –ü—ã—Ç–∞–µ–º—Å—è –ø–æ–ª—É—á–∏—Ç—å –∫—É—Ä—Å—ã –Ω–∞ –∑–∞–≤—Ç—Ä–∞
        rates_tomorrow, date_tomorrow_str = get_currency_rates_for_date(date_tomorrow)
        
        # –ï—Å–ª–∏ –∫—É—Ä—Å—ã –Ω–∞ –∑–∞–≤—Ç—Ä–∞ –Ω–µ –¥–æ—Å—Ç—É–ø–Ω—ã, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º —Ç–æ–ª—å–∫–æ —Å–µ–≥–æ–¥–Ω—è—à–Ω–∏–µ
        if not rates_tomorrow:
            return rates_today, date_today_str, None, None
        
        # –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º –∏–∑–º–µ–Ω–µ–Ω–∏—è –¥–ª—è –∑–∞–≤—Ç—Ä–∞—à–Ω–∏—Ö –∫—É—Ä—Å–æ–≤
        changes = {}
        for currency, today_data in rates_today.items():
            if currency in rates_tomorrow:
                today_value = today_data['value']
                tomorrow_value = rates_tomorrow[currency]['value']
                change = tomorrow_value - today_value
                change_percent = (change / today_value) * 100 if today_value > 0 else 0
                
                changes[currency] = {
                    'change': change,
                    'change_percent': change_percent
                }
        
        return rates_today, date_today_str, rates_tomorrow, changes
        
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –∫—É—Ä—Å–æ–≤ —Å –∑–∞–≤—Ç—Ä–∞—à–Ω–∏–º–∏ –¥–∞–Ω–Ω—ã–º–∏: {e}")
        return {}, '–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –¥–∞—Ç–∞', None, None

def format_currency_rates_message(rates_today: dict, date_today: str, 
                                rates_tomorrow: dict = None, changes: dict = None) -> str:
    """–§–æ—Ä–º–∞—Ç–∏—Ä—É–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–µ —Å –∫—É—Ä—Å–∞–º–∏ –≤–∞–ª—é—Ç –Ω–∞ —Å–µ–≥–æ–¥–Ω—è –∏ –∑–∞–≤—Ç—Ä–∞"""
    if not rates_today:
        return "‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –∫—É—Ä—Å—ã –≤–∞–ª—é—Ç –æ—Ç –¶–ë –†–§."
    
    message = f"üí± <b>–ö–£–†–°–´ –í–ê–õ–Æ–¢ –¶–ë –†–§</b>\n"
    message += f"üìÖ <i>–Ω–∞ {date_today}</i>\n\n"
    
    # –û—Å–Ω–æ–≤–Ω—ã–µ –≤–∞–ª—é—Ç—ã (–¥–æ–ª–ª–∞—Ä, –µ–≤—Ä–æ)
    main_currencies = ['USD', 'EUR']
    for currency in main_currencies:
        if currency in rates_today:
            data = rates_today[currency]
            
            message += f"üíµ <b>{data['name']}</b> ({currency}):\n"
            message += f"   <b>{data['value']:.2f} —Ä—É–±.</b>\n"
            
            # –ï—Å–ª–∏ –µ—Å—Ç—å –¥–∞–Ω–Ω—ã–µ –Ω–∞ –∑–∞–≤—Ç—Ä–∞, –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –ø—Ä–æ–≥–Ω–æ–∑
            if rates_tomorrow and currency in rates_tomorrow and currency in changes:
                tomorrow_data = rates_tomorrow[currency]
                change_info = changes[currency]
                change_icon = "üìà" if change_info['change'] > 0 else "üìâ" if change_info['change'] < 0 else "‚û°Ô∏è"
                
                message += f"   <i>–ó–∞–≤—Ç—Ä–∞: {tomorrow_data['value']:.2f} —Ä—É–±. {change_icon}</i>\n"
                message += f"   <i>–ò–∑–º–µ–Ω–µ–Ω–∏–µ: {change_info['change']:+.2f} —Ä—É–±. ({change_info['change_percent']:+.2f}%)</i>\n"
            
            message += "\n"
    
    # –î—Ä—É–≥–∏–µ –≤–∞–ª—é—Ç—ã
    other_currencies = [curr for curr in rates_today.keys() if curr not in main_currencies]
    if other_currencies:
        message += "üåç <b>–î—Ä—É–≥–∏–µ –≤–∞–ª—é—Ç—ã:</b>\n"
        
        for currency in other_currencies:
            data = rates_today[currency]
            
            # –î–ª—è JPY –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –∑–∞ 100 –µ–¥–∏–Ω–∏—Ü
            if currency == 'JPY':
                display_value = data['value'] * 100
                currency_text = f"   {data['name']} ({currency}): <b>{display_value:.2f} —Ä—É–±.</b>"
            else:
                currency_text = f"   {data['name']} ({currency}): <b>{data['value']:.2f} —Ä—É–±.</b>"
            
            # –î–æ–±–∞–≤–ª—è–µ–º –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä –∏–∑–º–µ–Ω–µ–Ω–∏—è –¥–ª—è –∑–∞–≤—Ç—Ä–∞, –µ—Å–ª–∏ –µ—Å—Ç—å
            if rates_tomorrow and currency in rates_tomorrow and currency in changes:
                change_info = changes[currency]
                change_icon = "üìà" if change_info['change'] > 0 else "üìâ" if change_info['change'] < 0 else "‚û°Ô∏è"
                currency_text += f" {change_icon}"
            
            message += currency_text + "\n"
    
    # –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç–∏ –∑–∞–≤—Ç—Ä–∞—à–Ω–∏—Ö –∫—É—Ä—Å–æ–≤
    if rates_tomorrow:
        tomorrow_date = (datetime.now() + timedelta(days=1)).strftime('%d.%m.%Y')
        message += f"\nüìä <i>–ö—É—Ä—Å—ã –Ω–∞ –∑–∞–≤—Ç—Ä–∞ ({tomorrow_date}) –æ–ø—É–±–ª–∏–∫–æ–≤–∞–Ω—ã –¶–ë –†–§</i>"
    else:
        message += f"\nüí° <i>–ö—É—Ä—Å—ã –Ω–∞ –∑–∞–≤—Ç—Ä–∞ –±—É–¥—É—Ç –æ–ø—É–±–ª–∏–∫–æ–≤–∞–Ω—ã –¶–ë –†–§ –ø–æ–∑–∂–µ</i>"
    
    message += f"\n\nüí° <i>–û—Ñ–∏—Ü–∏–∞–ª—å–Ω—ã–µ –∫—É—Ä—Å—ã –¶–ë –†–§ —Å –ø—Ä–æ–≥–Ω–æ–∑–æ–º –Ω–∞ –∑–∞–≤—Ç—Ä–∞</i>"
    return message

# =============================================================================
# –§–£–ù–ö–¶–ò–ò –î–õ–Ø –†–ê–ë–û–¢–´ –° –ö–õ–Æ–ß–ï–í–û–ô –°–¢–ê–í–ö–û–ô –¶–ë –†–§
# =============================================================================

def get_key_rate():
    """–ü–æ–ª—É—á–∞–µ—Ç –∫–ª—é—á–µ–≤—É—é —Å—Ç–∞–≤–∫—É –¶–ë –†–§ —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö –º–µ—Ç–æ–¥–æ–≤"""
    
    # –°–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–±—É–µ–º –ø–∞—Ä—Å–∏–Ω–≥ HTML —Å –ø—Ä–∞–≤–∏–ª—å–Ω—ã–º–∏ –∑–∞–≥–æ–ª–æ–≤–∫–∞–º–∏
    key_rate_data = get_key_rate_html()
    if key_rate_data:
        return key_rate_data
    
    # –ï—Å–ª–∏ –Ω–µ –ø–æ–ª—É—á–∏–ª–æ—Å—å, –ø—Ä–æ–±—É–µ–º API
    logger.info("–ü–∞—Ä—Å–∏–Ω–≥ HTML –Ω–µ —É–¥–∞–ª—Å—è, –ø—Ä–æ–±—É–µ–º API...")
    key_rate_data = get_key_rate_api()
    if key_rate_data:
        return key_rate_data
    
    # –ï—Å–ª–∏ –æ–±–∞ –º–µ—Ç–æ–¥–∞ –Ω–µ —Å—Ä–∞–±–æ—Ç–∞–ª–∏, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –¥–µ–º–æ-–¥–∞–Ω–Ω—ã–µ
    logger.warning("–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –∞–∫—Ç—É–∞–ª—å–Ω—É—é –∫–ª—é—á–µ–≤—É—é —Å—Ç–∞–≤–∫—É, –∏—Å–ø–æ–ª—å–∑—É–µ–º –¥–µ–º–æ-–¥–∞–Ω–Ω—ã–µ")
    return get_key_rate_demo()

def get_key_rate_html():
    """–ü–∞—Ä—Å–∏–Ω–≥ –∫–ª—é—á–µ–≤–æ–π —Å—Ç–∞–≤–∫–∏ —Å —Å–∞–π—Ç–∞ –¶–ë –†–§"""
    try:
        url = "https://cbr.ru/hd_base/KeyRate/"
        
        headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
            'Accept-Language': 'ru-RU,ru;q=0.9,en-US;q=0.8,en;q=0.7',
            'Referer': 'https://www.cbr.ru/',
            'Connection': 'keep-alive',
        }
        
        # –î–æ–±–∞–≤–ª—è–µ–º –∑–∞–¥–µ—Ä–∂–∫—É —á—Ç–æ–±—ã –Ω–µ –≤—ã–≥–ª—è–¥–µ—Ç—å –∫–∞–∫ –±–æ—Ç
        import time
        time.sleep(1)
        
        response = requests.get(url, headers=headers, timeout=15)
        
        if response.status_code == 403:
            logger.error("–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω (403) –ø—Ä–∏ –ø–∞—Ä—Å–∏–Ω–≥–µ HTML")
            return None
        elif response.status_code != 200:
            logger.error(f"–û—à–∏–±–∫–∞ HTTP {response.status_code} –ø—Ä–∏ –ø–∞—Ä—Å–∏–Ω–≥–µ HTML")
            return None
            
        soup = BeautifulSoup(response.content, 'html.parser')
        
        # –ò—â–µ–º —Ç–∞–±–ª–∏—Ü—É —Å –∫–ª—é—á–µ–≤—ã–º–∏ —Å—Ç–∞–≤–∫–∞–º–∏
        table = soup.find('table', class_='data')
        if table:
            rows = table.find_all('tr')
            for i in range(1, min(len(rows), 10)):  # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–µ—Ä–≤—ã–µ 10 —Å—Ç—Ä–æ–∫
                cells = rows[i].find_all('td')
                if len(cells) >= 2:
                    date_str = cells[0].get_text(strip=True)
                    rate_str = cells[1].get_text(strip=True).replace(',', '.')
                    
                    try:
                        date_obj = datetime.strptime(date_str, '%d.%m.%Y')
                        # –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ –¥–∞—Ç–∞ –Ω–µ –≤ –±—É–¥—É—â–µ–º
                        if date_obj <= datetime.now():
                            rate_value = float(rate_str)
                            
                            return {
                                'rate': rate_value,
                                'date': date_obj.strftime('%d.%m.%Y'),
                                'is_current': True,
                                'source': 'cbr_parsed'
                            }
                    except ValueError:
                        continue
        
        return None
            
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–∞—Ä—Å–∏–Ω–≥–µ HTML –∫–ª—é—á–µ–≤–æ–π —Å—Ç–∞–≤–∫–∏: {e}")
        return None

def get_key_rate_api():
    """–ü–æ–ª—É—á–∞–µ—Ç –∫–ª—é—á–µ–≤—É—é —Å—Ç–∞–≤–∫—É —á–µ—Ä–µ–∑ API –¶–ë –†–§"""
    try:
        # –ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–π URL –¥–ª—è –∫–ª—é—á–µ–≤–æ–π —Å—Ç–∞–≤–∫–∏
        url = "https://www.cbr.ru/hd_base/KeyRate/?UniDbQuery.Posted=True&UniDbQuery.From=01.01.2020&UniDbQuery.To=31.12.2025"
        
        headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
        }
        
        response = requests.get(url, headers=headers, timeout=10)
        
        if response.status_code == 200:
            soup = BeautifulSoup(response.content, 'html.parser')
            table = soup.find('table', class_='data')
            
            if table:
                rows = table.find_all('tr')
                for i in range(1, min(len(rows), 5)):  # –ü–µ—Ä–≤—ã–µ 5 —Å—Ç—Ä–æ–∫
                    cells = rows[i].find_all('td')
                    if len(cells) >= 2:
                        date_str = cells[0].get_text(strip=True)
                        rate_str = cells[1].get_text(strip=True).replace(',', '.')
                        
                        try:
                            date_obj = datetime.strptime(date_str, '%d.%m.%Y')
                            if date_obj <= datetime.now():
                                rate_value = float(rate_str)
                                
                                return {
                                    'rate': rate_value,
                                    'date': date_str,
                                    'is_current': True,
                                    'source': 'cbr_api'
                                }
                        except ValueError:
                            continue
        return None
            
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –∫–ª—é—á–µ–≤–æ–π —Å—Ç–∞–≤–∫–∏ —á–µ—Ä–µ–∑ API: {e}")
        return None

def get_key_rate_demo():
    """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –¥–µ–º–æ-–¥–∞–Ω–Ω—ã–µ –∫–ª—é—á–µ–≤–æ–π —Å—Ç–∞–≤–∫–∏"""
    return {
        'rate': 16.0,  # –ü—Ä–∏–º–µ—Ä–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ
        'date': datetime.now().strftime('%d.%m.%Y'),
        'is_current': True,
        'source': 'demo'
    }

def get_meeting_dates():
    """–ü–∞—Ä—Å–∏—Ç –¥–∞—Ç—ã –∑–∞—Å–µ–¥–∞–Ω–∏–π –°–æ–≤–µ—Ç–∞ –¥–∏—Ä–µ–∫—Ç–æ—Ä–æ–≤ –¶–ë –†–§ –ø–æ –∫–ª—é—á–µ–≤–æ–π —Å—Ç–∞–≤–∫–µ"""
    try:
        urls = [
            "https://cbr.ru/dkp/cal_mp/",  # –û—Å–Ω–æ–≤–Ω–∞—è —Å—Ç—Ä–∞–Ω–∏—Ü–∞
        ]
        
        meeting_dates = []
        
        for url in urls:
            try:
                headers = {
                    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
                    'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
                    'Accept-Language': 'ru-RU,ru;q=0.9,en-US;q=0.8,en;q=0.7',
                    'Referer': 'https://www.cbr.ru/',
                }
                
                logger.info(f"–ü—ã—Ç–∞–µ–º—Å—è –ø–æ–ª—É—á–∏—Ç—å –¥–∞–Ω–Ω—ã–µ —Å {url}")
                response = requests.get(url, headers=headers, timeout=20)
                
                if response.status_code != 200:
                    logger.warning(f"–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å —Å—Ç—Ä–∞–Ω–∏—Ü—É {url}, —Å—Ç–∞—Ç—É—Å: {response.status_code}")
                    continue
                
                soup = BeautifulSoup(response.content, 'html.parser')
                logger.info(f"–°—Ç—Ä–∞–Ω–∏—Ü–∞ –∑–∞–≥—Ä—É–∂–µ–Ω–∞, –∏—â–µ–º –¥–∞–Ω–Ω—ã–µ...")
                
                # –ú–µ—Ç–æ–¥ 1: –ò—â–µ–º –≤ —Ç–∞–±–ª–∏—Ü–∞—Ö
                tables = soup.find_all('table')
                logger.info(f"–ù–∞–π–¥–µ–Ω–æ —Ç–∞–±–ª–∏—Ü: {len(tables)}")
                
                for i, table in enumerate(tables):
                    rows = table.find_all('tr')
                    for row in rows:
                        cells = row.find_all(['td', 'th'])
                        row_text = ' '.join([cell.get_text(strip=True) for cell in cells])
                        
                        # –ò—â–µ–º —Å—Ç—Ä–æ–∫–∏ —Å –∑–∞—Å–µ–¥–∞–Ω–∏—è–º–∏
                        if any(keyword in row_text.lower() for keyword in [
                            '–∑–∞—Å–µ–¥–∞–Ω–∏–µ —Å–æ–≤–µ—Ç–∞ –¥–∏—Ä–µ–∫—Ç–æ—Ä–æ–≤', 
                            '–∫–ª—é—á–µ–≤–∞—è —Å—Ç–∞–≤–∫–∞',
                            '—Å–æ–≤–µ—Ç –¥–∏—Ä–µ–∫—Ç–æ—Ä–æ–≤ —Ü–±',
                            '–∑–∞—Å–µ–¥–∞–Ω–∏–µ —Ü–±'
                        ]):
                            # –ü—ã—Ç–∞–µ–º—Å—è –∏–∑–≤–ª–µ—á—å –¥–∞—Ç—É
                            date_match = re.search(r'(\d{1,2}\s+(?:—è–Ω–≤–∞—Ä—è|—Ñ–µ–≤—Ä–∞–ª—è|–º–∞—Ä—Ç–∞|–∞–ø—Ä–µ–ª—è|–º–∞—è|–∏—é–Ω—è|–∏—é–ª—è|–∞–≤–≥—É—Å—Ç–∞|—Å–µ–Ω—Ç—è–±—Ä—è|–æ–∫—Ç—è–±—Ä—è|–Ω–æ—è–±—Ä—è|–¥–µ–∫–∞–±—Ä—è)\s+\d{4})', row_text)
                            if date_match:
                                date_text = date_match.group(1)
                                parsed_date = parse_russian_date(date_text)
                                if parsed_date and parsed_date > datetime.now():
                                    meeting_dates.append({
                                        'date_obj': parsed_date,
                                        'date_str': date_text,
                                        'formatted_date': parsed_date.strftime('%d.%m.%Y')
                                    })
                                    logger.info(f"–ù–∞–π–¥–µ–Ω–æ –∑–∞—Å–µ–¥–∞–Ω–∏–µ: {date_text}")
                
                # –ú–µ—Ç–æ–¥ 2: –ò—â–µ–º –ø–æ –≤—Å–µ–º—É —Ç–µ–∫—Å—Ç—É —Å—Ç—Ä–∞–Ω–∏—Ü—ã
                page_text = soup.get_text()
                date_pattern = r'(\d{1,2}\s+(?:—è–Ω–≤–∞—Ä—è|—Ñ–µ–≤—Ä–∞–ª—è|–º–∞—Ä—Ç–∞|–∞–ø—Ä–µ–ª—è|–º–∞—è|–∏—é–Ω—è|–∏—é–ª—è|–∞–≤–≥—É—Å—Ç–∞|—Å–µ–Ω—Ç—è–±—Ä—è|–æ–∫—Ç—è–±—Ä—è|–Ω–æ—è–±—Ä—è|–¥–µ–∫–∞–±—Ä—è)\s+\d{4})'
                dates = re.findall(date_pattern, page_text)
                
                # –§–∏–ª—å—Ç—Ä—É–µ–º —Ç–æ–ª—å–∫–æ –±—É–¥—É—â–∏–µ –¥–∞—Ç—ã
                for date_text in dates:
                    parsed_date = parse_russian_date(date_text)
                    if parsed_date and parsed_date > datetime.now():
                        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–æ–Ω—Ç–µ–∫—Å—Ç - –∏—â–µ–º —É–ø–æ–º–∏–Ω–∞–Ω–∏—è –æ –∑–∞—Å–µ–¥–∞–Ω–∏—è—Ö —Ä—è–¥–æ–º —Å –¥–∞—Ç–æ–π
                        context_start = max(0, page_text.find(date_text) - 100)
                        context_end = min(len(page_text), page_text.find(date_text) + 100)
                        context = page_text[context_start:context_end].lower()
                        
                        if any(keyword in context for keyword in [
                            '–∑–∞—Å–µ–¥–∞–Ω–∏–µ', '—Å–æ–≤–µ—Ç –¥–∏—Ä–µ–∫—Ç–æ—Ä–æ–≤', '—Ü–±', '–±–∞–Ω–∫ —Ä–æ—Å—Å–∏–∏', '–∫–ª—é—á–µ–≤–∞—è'
                        ]):
                            meeting_dates.append({
                                'date_obj': parsed_date,
                                'date_str': date_text,
                                'formatted_date': parsed_date.strftime('%d.%m.%Y')
                            })
                            logger.info(f"–ù–∞–π–¥–µ–Ω–æ –∑–∞—Å–µ–¥–∞–Ω–∏–µ (–ø–æ –∫–æ–Ω—Ç–µ–∫—Å—Ç—É): {date_text}")
                
            except Exception as e:
                logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–∞—Ä—Å–∏–Ω–≥–µ {url}: {e}")
                continue
        
        # –ï—Å–ª–∏ –Ω–µ –Ω–∞—à–ª–∏ –¥–∞–Ω–Ω—ã–µ —á–µ—Ä–µ–∑ –ø–∞—Ä—Å–∏–Ω–≥, –∏—Å–ø–æ–ª—å–∑—É–µ–º –∑–∞–ø–∞—Å–Ω–æ–π –≤–∞—Ä–∏–∞–Ω—Ç
        if not meeting_dates:
            logger.info("–ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ –¥–∞–Ω–Ω—ã–µ —á–µ—Ä–µ–∑ –ø–∞—Ä—Å–∏–Ω–≥, –∏—Å–ø–æ–ª—å–∑—É–µ–º –∑–∞–ø–∞—Å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ")
            return get_fallback_meeting_dates()
        
        # –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ –¥–∞—Ç–µ –∏ —É–±–∏—Ä–∞–µ–º –¥—É–±–ª–∏–∫–∞—Ç—ã
        unique_dates = {}
        for meeting in meeting_dates:
            date_key = meeting['formatted_date']
            if date_key not in unique_dates:
                unique_dates[date_key] = meeting
        
        sorted_meetings = sorted(unique_dates.values(), key=lambda x: x['date_obj'])
        
        # –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –≤—ã–≤–æ–¥–∏–º—ã—Ö –¥–∞—Ç (–±–ª–∏–∂–∞–π—à–∏–µ 6)
        return sorted_meetings[:6]
        
    except Exception as e:
        logger.error(f"–û–±—â–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –¥–∞—Ç –∑–∞—Å–µ–¥–∞–Ω–∏–π: {e}")
        return get_fallback_meeting_dates()

def get_fallback_meeting_dates():
    """–ó–∞–ø–∞—Å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –æ –∑–∞—Å–µ–¥–∞–Ω–∏—è—Ö –¶–ë –†–§"""
    try:
        # –°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–µ –¥–∞—Ç—ã –∑–∞—Å–µ–¥–∞–Ω–∏–π –¶–ë –†–§ (–ø—Ä–∏–º–µ—Ä–Ω—ã–µ)
        current_year = datetime.now().year
        next_year = current_year + 1
        
        # –¢–∏–ø–∏—á–Ω—ã–µ –¥–∞—Ç—ã –∑–∞—Å–µ–¥–∞–Ω–∏–π (–ø—Ä–∏–º–µ—Ä–Ω—ã–µ, –æ—Å–Ω–æ–≤–∞–Ω–Ω—ã–µ –Ω–∞ –∏—Å—Ç–æ—Ä–∏—á–µ—Å–∫–∏—Ö –¥–∞–Ω–Ω—ã—Ö)
        typical_dates = [
            f"15 —è–Ω–≤–∞—Ä—è {current_year} –≥–æ–¥–∞",
            f"12 —Ñ–µ–≤—Ä–∞–ª—è {current_year} –≥–æ–¥–∞", 
            f"15 –º–∞—Ä—Ç–∞ {current_year} –≥–æ–¥–∞",
            f{26} –∞–ø—Ä–µ–ª—è {current_year} –≥–æ–¥–∞",
            f"14 –∏—é–Ω—è {current_year} –≥–æ–¥–∞",
            f"26 –∏—é–ª—è {current_year} –≥–æ–¥–∞",
            f{13} —Å–µ–Ω—Ç—è–±—Ä—è {current_year} –≥–æ–¥–∞",
            f"25 –æ–∫—Ç—è–±—Ä—è {current_year} –≥–æ–¥–∞",
            f"13 –¥–µ–∫–∞–±—Ä—è {current_year} –≥–æ–¥–∞",
            f"14 —Ñ–µ–≤—Ä–∞–ª—è {next_year} –≥–æ–¥–∞",
            f"18 –∞–ø—Ä–µ–ª—è {next_year} –≥–æ–¥–∞",
            f"13 –∏—é–Ω—è {next_year} –≥–æ–¥–∞"
        ]
        
        meeting_dates = []
        for date_text in typical_dates:
            parsed_date = parse_russian_date(date_text)
            if parsed_date and parsed_date > datetime.now():
                meeting_dates.append({
                    'date_obj': parsed_date,
                    'date_str': date_text,
                    'formatted_date': parsed_date.strftime('%d.%m.%Y')
                })
        
        # –°–æ—Ä—Ç–∏—Ä—É–µ–º –∏ –±–µ—Ä–µ–º –±–ª–∏–∂–∞–π—à–∏–µ 6
        sorted_meetings = sorted(meeting_dates, key=lambda x: x['date_obj'])
        return sorted_meetings[:6]
        
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –≤ –∑–∞–ø–∞—Å–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö: {e}")
        return []

def parse_russian_date(date_text):
    """–ü–∞—Ä—Å–∏—Ç —Ä—É—Å—Å–∫—É—é –¥–∞—Ç—É –≤ –æ–±—ä–µ–∫—Ç datetime"""
    try:
        # –°–ª–æ–≤–∞—Ä—å –¥–ª—è –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è –º–µ—Å—è—Ü–µ–≤
        months = {
            '—è–Ω–≤–∞—Ä—è': 1, '—Ñ–µ–≤—Ä–∞–ª—è': 2, '–º–∞—Ä—Ç–∞': 3, '–∞–ø—Ä–µ–ª—è': 4,
            '–º–∞—è': 5, '–∏—é–Ω—è': 6, '–∏—é–ª—è': 7, '–∞–≤–≥—É—Å—Ç–∞': 8,
            '—Å–µ–Ω—Ç—è–±—Ä—è': 9, '–æ–∫—Ç—è–±—Ä—è': 10, '–Ω–æ—è–±—Ä—è': 11, '–¥–µ–∫–∞–±—Ä—è': 12
        }
        
        # –£–±–∏—Ä–∞–µ–º "–≥–æ–¥–∞" –∏ –ª–∏—à–Ω–∏–µ –ø—Ä–æ–±–µ–ª—ã
        date_text = date_text.replace('–≥–æ–¥–∞', '').strip()
        
        # –†–∞–∑–±–∏–≤–∞–µ–º –Ω–∞ —á–∞—Å—Ç–∏
        parts = date_text.split()
        if len(parts) >= 3:
            day = int(parts[0])
            month_str = parts[1].lower()
            year = int(parts[2])
            
            if month_str in months:
                month = months[month_str]
                return datetime(year, month, day)
        
        return None
        
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ –¥–∞—Ç—ã '{date_text}': {e}")
        return None

def get_key_rate_with_meetings():
    """–ü–æ–ª—É—á–∞–µ—Ç –∫–ª—é—á–µ–≤—É—é —Å—Ç–∞–≤–∫—É –∏ –¥–∞—Ç—ã –∑–∞—Å–µ–¥–∞–Ω–∏–π"""
    try:
        key_rate_data = get_key_rate()
        meeting_dates = get_meeting_dates()
        
        return {
            'key_rate': key_rate_data,
            'meetings': meeting_dates
        }
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –≤ get_key_rate_with_meetings: {e}")
        return {
            'key_rate': get_key_rate(),
            'meetings': []
        }

def format_key_rate_message(key_rate_data: dict, meeting_dates: list = None) -> str:
    """–§–æ—Ä–º–∞—Ç–∏—Ä—É–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–µ —Å –∫–ª—é—á–µ–≤–æ–π —Å—Ç–∞–≤–∫–æ–π –∏ –¥–∞—Ç–∞–º–∏ –∑–∞—Å–µ–¥–∞–Ω–∏–π"""
    if not key_rate_data:
        return "‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –¥–∞–Ω–Ω—ã–µ –ø–æ –∫–ª—é—á–µ–≤–æ–π —Å—Ç–∞–≤–∫–µ –æ—Ç –¶–ë –†–§."
    
    rate = key_rate_data['rate']
    source = key_rate_data.get('source', 'unknown')
    
    message = f"üíé <b>–ö–õ–Æ–ß–ï–í–ê–Ø –°–¢–ê–í–ö–ê –¶–ë –†–§</b>\n\n"
    message += f"<b>–¢–µ–∫—É—â–µ–µ –∑–Ω–∞—á–µ–Ω–∏–µ:</b> {rate:.2f}%\n"
    message += f"<b>–î–∞—Ç–∞ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è:</b> {key_rate_data.get('date', '–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–æ')}\n\n"
    
    # –î–æ–±–∞–≤–ª—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –∑–∞—Å–µ–¥–∞–Ω–∏—è—Ö
    if meeting_dates:
        message += "<b>–°–ª–µ–¥—É—é—â–∏–µ –∑–∞—Å–µ–¥–∞–Ω–∏—è –¶–ë –†–§:</b>\n"
        for i, meeting in enumerate(meeting_dates, 1):
            message += f"‚Ä¢ {meeting['date_str']}\n"
        message += "\n"
    else:
        message += "<i>–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –¥–∞—Ç–∞—Ö –∑–∞—Å–µ–¥–∞–Ω–∏–π –≤—Ä–µ–º–µ–Ω–Ω–æ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞</i>\n\n"
    
    message += "üí° <i>–ö–ª—é—á–µ–≤–∞—è —Å—Ç–∞–≤–∫–∞ - —ç—Ç–æ –æ—Å–Ω–æ–≤–Ω–∞—è –ø—Ä–æ—Ü–µ–Ω—Ç–Ω–∞—è —Å—Ç–∞–≤–∫–∞ –¶–ë –†–§,\n"
    message += "–∫–æ—Ç–æ—Ä–∞—è –≤–ª–∏—è–µ—Ç –Ω–∞ –∫—Ä–µ–¥–∏—Ç—ã, –¥–µ–ø–æ–∑–∏—Ç—ã –∏ —ç–∫–æ–Ω–æ–º–∏–∫—É –≤ —Ü–µ–ª–æ–º</i>"
    
    # –î–æ–±–∞–≤–ª—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ–± –∏—Å—Ç–æ—á–Ω–∏–∫–µ –¥–∞–Ω–Ω—ã—Ö
    if source == 'cbr_parsed':
        message += f"\n\n‚úÖ <i>–î–∞–Ω–Ω—ã–µ –ø–æ–ª—É—á–µ–Ω—ã —Å –æ—Ñ–∏—Ü–∏–∞–ª—å–Ω–æ–≥–æ —Å–∞–π—Ç–∞ –¶–ë –†–§</i>"
    elif source == 'cbr_api':
        message += f"\n\n‚úÖ <i>–î–∞–Ω–Ω—ã–µ –ø–æ–ª—É—á–µ–Ω—ã —á–µ—Ä–µ–∑ API –¶–ë –†–§</i>"
    elif source == 'demo':
        message += f"\n\n‚ö†Ô∏è <i>–ò—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–æ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ (–æ—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Ä–µ–∞–ª—å–Ω—ã—Ö)</i>"
    
    return message


# =============================================================================
# –§–£–ù–ö–¶–ò–ò –î–õ–Ø –†–ê–ë–û–¢–´ –° –ö–†–ò–ü–¢–û–í–ê–õ–Æ–¢–ê–ú–ò
# =============================================================================

def get_crypto_rates():
    """–ü–æ–ª—É—á–∞–µ—Ç –∫—É—Ä—Å—ã –∫—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç —á–µ—Ä–µ–∑ CoinGecko API"""
    try:
        # –û—Å–Ω–æ–≤–Ω—ã–µ –∫—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç—ã –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è
        crypto_ids = [
            'bitcoin', 'ethereum', 'binancecoin', 'ripple', 'cardano',
            'solana', 'polkadot', 'dogecoin', 'tron', 'litecoin'
        ]
        
        url = f"{COINGECKO_API_BASE}simple/price"
        params = {
            'ids': ','.join(crypto_ids),
            'vs_currencies': 'rub,usd',
            'include_24hr_change': 'true',
            'include_last_updated_at': 'true'
        }
        
        headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
            'Accept': 'application/json'
        }
        
        logger.info(f"–ó–∞–ø—Ä–æ—Å –∫ CoinGecko API: {url}")
        
        response = requests.get(url, params=params, headers=headers, timeout=15)
        
        if response.status_code != 200:
            logger.error(f"–û—à–∏–±–∫–∞ CoinGecko API: {response.status_code}")
            return None
            
        data = response.json()
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—Ç—Ä—É–∫—Ç—É—Ä—É –æ—Ç–≤–µ—Ç–∞
        if not isinstance(data, dict):
            logger.error(f"–ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –æ—Ç–≤–µ—Ç–∞: –æ–∂–∏–¥–∞–ª—Å—è dict, –ø–æ–ª—É—á–µ–Ω {type(data)}")
            return None
            
        # –ú–∞–ø–ø–∏–Ω–≥ –Ω–∞–∑–≤–∞–Ω–∏–π –∫—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç
        crypto_names = {
            'bitcoin': {'name': 'Bitcoin', 'symbol': 'BTC'},
            'ethereum': {'name': 'Ethereum', 'symbol': 'ETH'},
            'binancecoin': {'name': 'Binance Coin', 'symbol': 'BNB'},
            'ripple': {'name': 'XRP', 'symbol': 'XRP'},
            'cardano': {'name': 'Cardano', 'symbol': 'ADA'},
            'solana': {'name': 'Solana', 'symbol': 'SOL'},
            'polkadot': {'name': 'Polkadot', 'symbol': 'DOT'},
            'dogecoin': {'name': 'Dogecoin', 'symbol': 'DOGE'},
            'tron': {'name': 'TRON', 'symbol': 'TRX'},
            'litecoin': {'name': 'Litecoin', 'symbol': 'LTC'}
        }
        
        crypto_rates = {}
        valid_count = 0
        
        for crypto_id, info in crypto_names.items():
            if crypto_id in data:
                crypto_data = data[crypto_id]
                
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ crypto_data - —Å–ª–æ–≤–∞—Ä—å
                if not isinstance(crypto_data, dict):
                    logger.warning(f"–î–∞–Ω–Ω—ã–µ –¥–ª—è {crypto_id} –Ω–µ —Å–ª–æ–≤–∞—Ä—å: {type(crypto_data)}")
                    continue
                
                # –ü–æ–ª—É—á–∞–µ–º —Ü–µ–Ω—ã —Å –ø—Ä–æ–≤–µ—Ä–∫–æ–π
                price_rub = crypto_data.get('rub')
                price_usd = crypto_data.get('usd')
                
                # –ü–æ–ª—É—á–∞–µ–º –∏–∑–º–µ–Ω–µ–Ω–∏–µ —Ü–µ–Ω—ã (–º–æ–∂–µ—Ç –±—ã—Ç—å –ø–æ–¥ —Ä–∞–∑–Ω—ã–º–∏ –∫–ª—é—á–∞–º–∏)
                change_24h = crypto_data.get('rub_24h_change') or crypto_data.get('usd_24h_change') or 0
                
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ —Ü–µ–Ω—ã –µ—Å—Ç—å –∏ –æ–Ω–∏ —á–∏—Å–ª–∞
                if price_rub is None or price_usd is None:
                    logger.warning(f"–û—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç —Ü–µ–Ω—ã –¥–ª—è {crypto_id}: RUB={price_rub}, USD={price_usd}")
                    continue
                
                try:
                    price_rub = float(price_rub)
                    price_usd = float(price_usd)
                    change_24h = float(change_24h) if change_24h is not None else 0
                except (TypeError, ValueError) as e:
                    logger.warning(f"–û—à–∏–±–∫–∞ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö –¥–ª—è {crypto_id}: {e}")
                    continue
                
                crypto_rates[crypto_id] = {
                    'name': info['name'],
                    'symbol': info['symbol'],
                    'price_rub': price_rub,
                    'price_usd': price_usd,
                    'change_24h': change_24h,
                    'last_updated': crypto_data.get('last_updated_at', 0)
                }
                valid_count += 1
        
        logger.info(f"–£—Å–ø–µ—à–Ω–æ –æ–±—Ä–∞–±–æ—Ç–∞–Ω–æ {valid_count} –∫—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç")
        
        if crypto_rates:
            crypto_rates['update_time'] = datetime.now().strftime('%d.%m.%Y %H:%M')
            crypto_rates['source'] = 'coingecko'
            return crypto_rates
        else:
            logger.error("–ù–µ –Ω–∞–π–¥–µ–Ω–æ –≤–∞–ª–∏–¥–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö –ø–æ –∫—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç–∞–º –≤ –æ—Ç–≤–µ—Ç–µ API")
            return None
            
    except requests.exceptions.RequestException as e:
        logger.error(f"–°–µ—Ç–µ–≤–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –∫—É—Ä—Å–æ–≤ –∫—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç: {e}")
        return None
    except json.JSONDecodeError as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ JSON –æ—Ç CoinGecko: {e}")
        return None
    except Exception as e:
        logger.error(f"–ù–µ–æ–∂–∏–¥–∞–Ω–Ω–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –∫—É—Ä—Å–æ–≤ –∫—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç: {e}")
        return None

def get_crypto_rates_fallback():
    """–†–µ–∑–µ—Ä–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –∫—É—Ä—Å–æ–≤ –∫—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç (–¥–µ–º–æ-–¥–∞–Ω–Ω—ã–µ)"""
    try:
        # –î–µ–º–æ-–¥–∞–Ω–Ω—ã–µ –Ω–∞ —Å–ª—É—á–∞–π –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç–∏ API
        crypto_rates = {
            'bitcoin': {
                'name': 'Bitcoin',
                'symbol': 'BTC',
                'price_rub': 4500000.0,
                'price_usd': 50000.0,
                'change_24h': 2.5,
                'last_updated': datetime.now().timestamp()
            },
            'ethereum': {
                'name': 'Ethereum', 
                'symbol': 'ETH',
                'price_rub': 300000.0,
                'price_usd': 3300.0,
                'change_24h': 1.2,
                'last_updated': datetime.now().timestamp()
            },
            'binancecoin': {
                'name': 'Binance Coin',
                'symbol': 'BNB', 
                'price_rub': 35000.0,
                'price_usd': 380.0,
                'change_24h': -0.5,
                'last_updated': datetime.now().timestamp()
            }
        }
        
        crypto_rates['update_time'] = datetime.now().strftime('%d.%m.%Y %H:%M')
        crypto_rates['source'] = 'demo_fallback'
        
        logger.info("–ò—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è –¥–µ–º–æ-–¥–∞–Ω–Ω—ã–µ –∫—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç")
        return crypto_rates
        
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –≤ fallback —Ñ—É–Ω–∫—Ü–∏–∏ –∫—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç: {e}")
        return None

def format_crypto_rates_message(crypto_rates: dict) -> str:
    """–§–æ—Ä–º–∞—Ç–∏—Ä—É–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–µ —Å –∫—É—Ä—Å–∞–º–∏ –∫—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç"""
    if not crypto_rates:
        return "‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –∫—É—Ä—Å—ã –∫—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç –æ—Ç CoinGecko API."
    
    message = f"‚Çø <b>–ö–£–†–°–´ –ö–†–ò–ü–¢–û–í–ê–õ–Æ–¢</b>\n\n"
    
    # –û—Å–Ω–æ–≤–Ω—ã–µ –∫—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç—ã
    main_cryptos = ['bitcoin', 'ethereum', 'binancecoin']
    
    for crypto_id in main_cryptos:
        if crypto_id in crypto_rates:
            data = crypto_rates[crypto_id]
            
            # –ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ –ø–æ–ª—É—á–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö
            name = data.get('name', 'N/A')
            symbol = data.get('symbol', 'N/A')
            price_rub = data.get('price_rub', 0)
            price_usd = data.get('price_usd', 0)
            change_24h = data.get('change_24h', 0)
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç–∏–ø—ã –¥–∞–Ω–Ω—ã—Ö
            try:
                price_rub = float(price_rub)
                price_usd = float(price_usd)
                change_24h = float(change_24h)
            except (TypeError, ValueError):
                continue
            
            change_icon = "üìà" if change_24h > 0 else "üìâ" if change_24h < 0 else "‚û°Ô∏è"
            
            message += (
                f"<b>{name} ({symbol})</b>\n"
                f"   üí∞ <b>{price_rub:,.0f} —Ä—É–±.</b>\n"
                f"   üíµ {price_usd:,.2f} $\n"
                f"   {change_icon} <i>{change_24h:+.2f}% (24—á)</i>\n\n"
            )
    
    message += f"\n<i>–û–±–Ω–æ–≤–ª–µ–Ω–æ: {crypto_rates.get('update_time', '–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–æ')}</i>\n\n"
    message += "üí° <i>–î–∞–Ω–Ω—ã–µ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª–µ–Ω—ã CoinGecko API</i>"
    
    if crypto_rates.get('source') == 'coingecko':
        message += f"\n\n‚úÖ <i>–û—Ñ–∏—Ü–∏–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ CoinGecko</i>"
    
    return message

# =============================================================================
# –§–£–ù–ö–¶–ò–ò –î–õ–Ø –†–ê–ë–û–¢–´ –° –ò–ò DEEPSEEK
# =============================================================================

async def ask_deepseek(prompt: str, context: ContextTypes.DEFAULT_TYPE = None) -> str:
    """–û—Ç–ø—Ä–∞–≤–ª—è–µ—Ç –∑–∞–ø—Ä–æ—Å –∫ API DeepSeek –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –æ—Ç–≤–µ—Ç"""
    if not DEEPSEEK_API_KEY:
        return "‚ùå –§—É–Ω–∫—Ü–∏–æ–Ω–∞–ª –ò–ò –≤—Ä–µ–º–µ–Ω–Ω–æ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω. –û—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç API –∫–ª—é—á."
    
    try:
        url = f"{DEEPSEEK_API_BASE}chat/completions"
        
        headers = {
            'Content-Type': 'application/json',
            'Authorization': f'Bearer {DEEPSEEK_API_KEY}'
        }
        
        # –£–ù–ò–í–ï–†–°–ê–õ–¨–ù–´–ô –ü–†–û–ú–ü–¢ –î–õ–Ø –õ–Æ–ë–´–• –í–û–ü–†–û–°–û–í
        system_message = """–¢—ã - —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–π –ò–ò –ø–æ–º–æ—â–Ω–∏–∫ –≤ —Ç–µ–ª–µ–≥—Ä–∞–º –±–æ—Ç–µ. –¢—ã –ø–æ–º–æ–≥–∞–µ—à—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º —Å –ª—é–±—ã–º–∏ –≤–æ–ø—Ä–æ—Å–∞–º–∏, –≤–∫–ª—é—á–∞—è:

- üí∞ –§–∏–Ω–∞–Ω—Å—ã: –∫—É—Ä—Å—ã –≤–∞–ª—é—Ç, –∏–Ω–≤–µ—Å—Ç–∏—Ü–∏–∏, –∫—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç—ã
- üìä –¢–µ—Ö–Ω–æ–ª–æ–≥–∏–∏: –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏–µ, IT, —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∞
- üéì –û–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ: –æ–±—É—á–µ–Ω–∏–µ, –Ω–∞—É–∫–∏, –∏—Å—Å–ª–µ–¥–æ–≤–∞–Ω–∏—è
- üé® –¢–≤–æ—Ä—á–µ—Å—Ç–≤–æ: –∏—Å–∫—É—Å—Å—Ç–≤–æ, –º—É–∑—ã–∫–∞, –ª–∏—Ç–µ—Ä–∞—Ç—É—Ä–∞
- üè• –ó–¥–æ—Ä–æ–≤—å–µ: –º–µ–¥–∏—Ü–∏–Ω–∞, —Å–ø–æ—Ä—Ç, –æ–±—Ä–∞–∑ –∂–∏–∑–Ω–∏
- üåç –ü—É—Ç–µ—à–µ—Å—Ç–≤–∏—è: —Å—Ç—Ä–∞–Ω—ã, –∫—É–ª—å—Ç—É—Ä–∞, —è–∑—ã–∫–∏
- üîß –°–æ–≤–µ—Ç—ã: —Ä–µ—à–µ–Ω–∏–µ –ø—Ä–æ–±–ª–µ–º, —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏
- üí¨ –û–±—â–µ–Ω–∏–µ: –ø–æ–¥–¥–µ—Ä–∂–∫–∞, –º–æ—Ç–∏–≤–∞—Ü–∏—è

–û—Ç–≤–µ—á–∞–π –ø–æ–¥—Ä–æ–±–Ω–æ, –∏–Ω—Ñ–æ—Ä–º–∞—Ç–∏–≤–Ω–æ –∏ –ø–æ–º–æ–≥–∞—é—â–µ. –ë—É–¥—å –¥—Ä—É–∂–µ–ª—é–±–Ω—ã–º –∏ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—â–∏–º —Å–æ–±–µ—Å–µ–¥–Ω–∏–∫–æ–º."""
        
        data = {
            "model": "deepseek-chat",
            "messages": [
                {"role": "system", "content": system_message},
                {"role": "user", "content": prompt}
            ],
            "temperature": 0.7,
            "max_tokens": 2000,
            "stream": False
        }
        
        logger.info(f"–û—Ç–ø—Ä–∞–≤–∫–∞ –∑–∞–ø—Ä–æ—Å–∞ –∫ DeepSeek API: {prompt[:100]}...")
        
        response = requests.post(url, headers=headers, json=data, timeout=30)
        
        if response.status_code == 200:
            result = response.json()
            answer = result['choices'][0]['message']['content']
            logger.info("–£—Å–ø–µ—à–Ω–æ –ø–æ–ª—É—á–µ–Ω –æ—Ç–≤–µ—Ç –æ—Ç DeepSeek API")
            return answer
        elif response.status_code == 402:
            logger.error("–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å—Ä–µ–¥—Å—Ç–≤ –Ω–∞ —Å—á–µ—Ç—É DeepSeek API")
            return "‚ùå –§—É–Ω–∫—Ü–∏–æ–Ω–∞–ª –ò–ò –≤—Ä–µ–º–µ–Ω–Ω–æ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω. –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å—Ä–µ–¥—Å—Ç–≤ –Ω–∞ API –∞–∫–∫–∞—É–Ω—Ç–µ. –û–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É."
        elif response.status_code == 401:
            logger.error("–ù–µ–≤–µ—Ä–Ω—ã–π API –∫–ª—é—á DeepSeek")
            return "‚ùå –û—à–∏–±–∫–∞ –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–∏ API. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ API –∫–ª—é—á."
        elif response.status_code == 429:
            logger.error("–ü—Ä–µ–≤—ã—à–µ–Ω –ª–∏–º–∏—Ç –∑–∞–ø—Ä–æ—Å–æ–≤ –∫ DeepSeek API")
            return "‚è∞ –ü—Ä–µ–≤—ã—à–µ–Ω –ª–∏–º–∏—Ç –∑–∞–ø—Ä–æ—Å–æ–≤. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ."
        else:
            error_msg = f"–û—à–∏–±–∫–∞ API DeepSeek: {response.status_code} - {response.text}"
            logger.error(error_msg)
            return f"‚ùå –í—Ä–µ–º–µ–Ω–Ω–∞—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–∏—Å–∞ –ò–ò. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ."
            
    except requests.exceptions.Timeout:
        logger.error("–¢–∞–π–º–∞—É—Ç –ø—Ä–∏ –∑–∞–ø—Ä–æ—Å–µ –∫ DeepSeek API")
        return "‚è∞ –ò–ò –Ω–µ —É—Å–ø–µ–ª –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å –∑–∞–ø—Ä–æ—Å. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ."
    except requests.exceptions.RequestException as e:
        logger.error(f"–°–µ—Ç–µ–≤–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø—Ä–æ—Å–µ –∫ DeepSeek API: {e}")
        return "‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ —Å–µ—Ç–µ–≤–∞—è –æ—à–∏–±–∫–∞. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ –∏–Ω—Ç–µ—Ä–Ω–µ—Ç—É."
    except Exception as e:
        logger.error(f"–ù–µ–æ–∂–∏–¥–∞–Ω–Ω–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–∞–±–æ—Ç–µ —Å DeepSeek API: {e}")
        return "‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –Ω–µ–ø—Ä–µ–¥–≤–∏–¥–µ–Ω–Ω–∞—è –æ—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ."
